/*
 * bsp_nrf.c
 *
 *  Created on: 2017-9-6
 *      Author: echo
 */
#include "app_timer.h"
#include "app_button.h"
#include "app_uart.h"
#include "app_util_platform.h"
#include "bsp.h"
#include "bsp_btn_ble.h"
#include "ble_hci.h"
#include "nrf_drv_uart.h"
#include "nrf_drv_gpiote.h"

#include "port.h"
#include "app.h"

extern uint16_t                         m_conn_handle;

//#define APP_TIMER_PRESCALER             0                                           /**< Value of the RTC1 PRESCALER register. */
#define APP_TIMER_OP_QUEUE_SIZE         4                                           /**< Size of timer operation queues. */

#define UART_TX_BUF_SIZE                256                                         /**< UART TX buffer size. */
#define UART_RX_BUF_SIZE                256                                         /**< UART RX buffer size. */

static void uart_init(void);
static void buttons_leds_init(bool * p_erase_bonds);

 void in_pin_handler()
 {
    wistar_uart_init();
 }

 void uart_interruput_pin_init(uint32_t pin_number)
 {
     uint32_t err_code;
    //uart wake_up pin interrupt config
    err_code = nrf_drv_gpiote_init();
    APP_ERROR_CHECK(err_code);

    nrf_gpio_cfg(pin_number,NRF_GPIO_PIN_DIR_INPUT,NRF_GPIO_PIN_INPUT_CONNECT,
        NRF_GPIO_PIN_PULLUP,NRF_GPIO_PIN_S0S1,NRF_GPIO_PIN_NOSENSE);

    nrf_drv_gpiote_in_config_t in_config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(false);

    err_code = nrf_drv_gpiote_in_init(pin_number, &in_config, in_pin_handler);
    APP_ERROR_CHECK(err_code);

    nrf_drv_gpiote_in_event_enable(pin_number, true);
 }
 
 void bsp_nrf_init(void)
 {
    bool erase_bonds;

//	bsp_board_leds_init();

    // Initialize.
    APP_TIMER_INIT(APP_TIMER_PRESCALER, APP_TIMER_OP_QUEUE_SIZE, false);
//    uart_init();

//    wistar_uart_init();  //for debug printf

//    buttons_leds_init(&erase_bonds);

#ifdef CURTAIN_LOW_POWER
    uart_interruput_pin_init(12);
#endif
 }
 
 /**@brief Function for handling events from the BSP module.
 *
 * @param[in]   event   Event generated by button press.
 */
void bsp_event_handler(bsp_event_t event)
{
    uint32_t err_code;
    switch (event)
    {
        case BSP_EVENT_SLEEP:
            sleep_mode_enter();
            break;

        case BSP_EVENT_DISCONNECT:
            err_code = sd_ble_gap_disconnect(m_conn_handle, BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
            if (err_code != NRF_ERROR_INVALID_STATE)
            {
                APP_ERROR_CHECK(err_code);
            }
            break;

        case BSP_EVENT_WHITELIST_OFF:
            if (m_conn_handle == BLE_CONN_HANDLE_INVALID)
            {
                err_code = ble_advertising_restart_without_whitelist();
                if (err_code != NRF_ERROR_INVALID_STATE)
                {
                    APP_ERROR_CHECK(err_code);
                }
            }
            break;

		case BSP_EVENT_PLUG_KEY:
			//plug_switch();
			break;
		
		case BSP_EVENT_PLUG_KEY_LONG:
			//tuya_device_unbond();
			//tuya_device_reboot(1000);
			break;
		
        default:
            break;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////

APP_TIMER_DEF(uart_packet_timer_id);
uint8_t isHaveContinueData;

/**@brief   Function for handling app_uart events.
 *
 * @details This function will receive a single character from the app_uart module and append it to
 *          a string. The string will be be sent over BLE when the last character received was a
 *          'new line' i.e '\r\n' (hex 0x0D) or if the string has reached a length of
 *          @ref NUS_MAX_DATA_LENGTH.
 */
/**@snippet [Handling the data received over UART] */

static uart_packet_t uart_packet={0};
void uart_event_handle(app_uart_evt_t * p_event)
{
    //static uint8_t data_array[BLE_NUS_MAX_DATA_LEN];
    //static uint8_t index = 0;
    uint32_t       err_code;

    switch (p_event->evt_type)
    {
        case APP_UART_DATA_READY:
			/*
            UNUSED_VARIABLE(app_uart_get(&data_array[index]));
            index++;

            if ((data_array[index - 1] == '\n') || (index >= (BLE_NUS_MAX_DATA_LEN)))
            {
                err_code = ble_nus_string_send(&m_nus, data_array, index);
                if (err_code != NRF_ERROR_INVALID_STATE)
                {
                    APP_ERROR_CHECK(err_code);
                }

                index = 0;
            }
			*/
		
			//分包处理
			isHaveContinueData = 1;
		
			app_uart_get(&(uart_packet.data[uart_packet.len++]));//echo note here must be "&" 
		
			app_timer_stop(uart_packet_timer_id);
			app_timer_start(uart_packet_timer_id,APP_TIMER_TICKS(5,APP_TIMER_PRESCALER),NULL);
		
            break;
		case APP_UART_TX_EMPTY:
            //uart_send_fifo_flag = 1;
			break;
        case APP_UART_COMMUNICATION_ERROR:
            APP_ERROR_HANDLER(p_event->data.error_communication);
            break;

        case APP_UART_FIFO_ERROR:
            APP_ERROR_HANDLER(p_event->data.error_code);
            break;

        default:
            break;
    }
}
/**@snippet [Handling the data received over UART] */

/**
*	uart packet proc handler
*/
void uart_packet_proc_handler(void * p_context)
{
	isHaveContinueData = 0;
	
	printf("uart_packet.len=%d\r\n",uart_packet.len);
	
	ty_uart_data_callback(uart_packet.len,uart_packet.data);
	
	memset(&uart_packet,0x0,sizeof(uart_packet_t));
}


/**@brief  Function for initializing the UART module.
 */
/**@snippet [UART Initialization] */

static void uart_init(void)
{
    uint32_t                     err_code;
    const app_uart_comm_params_t comm_params =
    {
        RX_PIN_NUMBER,
        TX_PIN_NUMBER,
        RTS_PIN_NUMBER,
        CTS_PIN_NUMBER,
        APP_UART_FLOW_CONTROL_DISABLED,
        false,
        UART_BAUDRATE_BAUDRATE_Baud9600
    };

    APP_UART_FIFO_INIT( &comm_params,
                       UART_RX_BUF_SIZE,
                       UART_TX_BUF_SIZE,
                       uart_event_handle,
                       APP_IRQ_PRIORITY_LOWEST,
                       err_code);
    APP_ERROR_CHECK(err_code);
	
	//TODO timer
	app_timer_create(&uart_packet_timer_id,APP_TIMER_MODE_SINGLE_SHOT,uart_packet_proc_handler);
	app_timer_start(uart_packet_timer_id,APP_TIMER_TICKS(5,APP_TIMER_PRESCALER),NULL);
	
	isHaveContinueData = 0;
}
/**@snippet [UART Initialization] */
//////////////////////////////////////////////////////////////////////////////////////////////////////

extern BOOL uart_init_flag;
extern u8 ty_factory_flag;

void wistar_uart_init()
{
	if(!uart_init_flag)  {
        uart_init();
        uart_init_flag = 1;
//        bsp_board_led_on(2);
    }
}

void wistar_uart_close()
{
    if(!ty_factory_flag) {
        if(uart_init_flag) {
            app_uart_close();
            uart_init_flag = 0;
//            bsp_board_led_off(2);
        }
    }
    nrf_gpio_cfg(18,NRF_GPIO_PIN_DIR_OUTPUT,NRF_GPIO_PIN_INPUT_DISCONNECT,
            NRF_GPIO_PIN_PULLUP,NRF_GPIO_PIN_S0S1,NRF_GPIO_PIN_NOSENSE);
    nrf_gpio_pin_set(18);
    nrf_gpio_cfg_input(20, NRF_GPIO_PIN_PULLUP);
}

/**@brief Function for initializing buttons and leds.
 *
 * @param[out] p_erase_bonds  Will be true if the clear bonding button was pressed to wake the application up.
 */
static void buttons_leds_init(bool * p_erase_bonds)
{
    bsp_event_t startup_event;

    uint32_t err_code = bsp_init(BSP_INIT_LED | BSP_INIT_BUTTONS,
                                 APP_TIMER_TICKS(100, APP_TIMER_PRESCALER),
                                 bsp_event_handler);
    APP_ERROR_CHECK(err_code);

    err_code = bsp_btn_ble_init(NULL, &startup_event);
    APP_ERROR_CHECK(err_code);

    *p_erase_bonds = (startup_event == BSP_EVENT_CLEAR_BONDING_DATA);
}
